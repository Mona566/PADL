pragma solidity ^0.8.20;

import "./Secp256k.sol";


/// @title For Verification of proof of consistency of transaction
/// @author Applied research, Global Tech., JPMorgan Chase, London
/// @notice This is an code for research and experimentation.


contract ConsistencyProof {
    uint256 s1gs2hx;
    uint256 s1gs2hy;
    uint256 t2chalx;
    uint256 t2chaly;
    uint256 s2pkx;
    uint256 s2pky;
    uint256 chalx;
    uint256 chaly;
    uint256 t1ccmx;
    uint256 t1ccmy;
    bool b1 = true;
    bool b2 = true;
    bool b3 = true;

    Secp256k secp = new Secp256k();

    struct solpoint{
        uint256 x;
        uint256 y;
    }

    struct consistencyProofSolR{
        solpoint t1;
        solpoint t2;
        uint256 s1;
        uint256 s2;
        uint256 challenge;
        solpoint pubkey;
        solpoint cm;
        solpoint tk;
        solpoint chalcm;
        solpoint chaltk;
        solpoint s2pubkey;
        solpoint s1g;
        solpoint s2h;
    }
 
 
    uint256 gx = g;
    uint256 hx =  GX;
    uint8 gpref =  preg;
    uint8 hpref =  preg;
    uint8 pre = 0x04;
    uint8 zerobytes = 0x00;
    uint256 gy = secp.getY(gpref,gx);
    uint256 hy = secp.getY(hpref,hx);
    bytes b = abi.encodePacked(pre,gx,gy);



      /// @dev function to generate a consistency hash by concatenating several variables from a consistencyProofSolR structure, including public key, commitment, token.
      /// @param  prsol is a structure of consistencyProofSolR type that contains various fields.
      function getConsistencyHash(consistencyProofSolR memory prsol) public returns(bytes memory){
        b = pushToHash(b,hx,hy);
        b = pushToHash(b, prsol.t1.x,prsol.t1.y);
        b = pushToHash(b, prsol.t2.x, prsol.t2.y);
        b = pushToHash(b ,prsol.pubkey.x, prsol.pubkey.y);
        b = pushToHash(b, prsol.cm.x, prsol.cm.y);
        b = pushToHash(b, prsol.tk.x, prsol.tk.y);
        b = abi.encodePacked(b, zerobytes,zerobytes,zerobytes,zerobytes);
        return b;
    }

    /// @dev function to creat a compact representation of concatenated data, by appending the provided x and y values to the byte array b, along with a prefix pre.
    /// @param b  is an initial byte variable to which additional data can be concatenated.
    /// @param x  is the first 256-bit unsigned integer to be concatenated.
    /// @param y  is the second 256-bit unsigned integer to be concatenated.
    function pushToHash(bytes memory b, uint256 x, uint256 y) public returns(bytes memory) {
        return abi.encodePacked(b,pre,x,y);
    }

    /// @dev function to creat a compact representation of two sub hashes.
    /// @param prsol is a structure of consistencyProofSolR type that contains various fields.
    function getHash(consistencyProofSolR memory prsol) public returns(bytes memory){
        b = getHash1(prsol);
        b = getHash2(b, prsol);
        return b;
    }

    /// @dev function is to generates the first part of the hash by concatenating several predefined constants and fields from the prsol structure into a single byte array.
    /// @param prsol is a structure of consistencyProofSolR type that contains various fields.
    function getHash1(consistencyProofSolR memory prsol) public returns(bytes memory){
        return abi.encodePacked(pre,gx,gy,pre,hx,hy,pre,prsol.t1.x,prsol.t1.y,pre,prsol.t2.x, prsol.t2.y);
    }

    /// @dev function to generates the second part of the hash by concatenating additional fields from the prsol structure to the byte array b generated by getHash1.
    /// @param b is the initial byte array generated by function getHash1.
    /// @param prsol is a structure of consistencyProofSolR type that contains various fields.
    function getHash2(bytes memory b,consistencyProofSolR memory prsol) public returns(bytes memory){
        uint32 zerobytes32 = 0;
        return abi.encodePacked(b,pre,prsol.pubkey.x, prsol.pubkey.y,pre,prsol.cm.x, prsol.cm.y, pre, prsol.tk.x, prsol.tk.y,zerobytes32);
    }

    /// @dev function to verifies the proof of consistency by performing a series of elliptic curve operations and checks. 
    /// @param prsol is a structure of consistencyProofSolR type that contains various fields.
   function processConsistency(consistencyProofSolR memory prsol) public returns(bool){


        (bool b4, uint256 s1gx, uint256 s1gy) = secp.scalMulR(prsol.s1, gx, gy, prsol.s1g.x, prsol.s1g.y); 
        (bool b5, uint256 s2hx, uint256 s2hy) = secp.scalMulR(prsol.s2, hx, hy, prsol.s2h.x, prsol.s2h.y);
        (s1gs2hx, s1gs2hy) = secp.add(s1gx, s1gy, s2hx, s2hy); 

        (b1, chalx, chaly) = secp.scalMulR(prsol.challenge, prsol.cm.x, prsol.cm.y, prsol.chalcm.x, prsol.chalcm.y);
        (t1ccmx, t1ccmy) = secp.add(prsol.t1.x, prsol.t1.y, chalx, chaly);

        (b3, chalx, chaly) = secp.scalMulR(prsol.challenge, prsol.tk.x, prsol.tk.y, prsol.chaltk.x, prsol.chaltk.y);
        (b2, s2pkx, s2pky) = secp.scalMulR(prsol.s2, prsol.pubkey.x, prsol.pubkey.y, prsol.s2pubkey.x, prsol.s2pubkey.y);
        (t2chalx, t2chaly) = secp.add(prsol.t2.x, prsol.t2.y, chalx, chaly);

        uint256 hchal = uint256(sha256(getHash(prsol))); 

        if (s1gs2hx == t1ccmx && s1gs2hy == t1ccmy && s2pkx == t2chalx && s2pky == t2chaly && hchal == prsol.challenge){
            return (true && b1 && b2 && b3 && b4 && b5);
        }

        return false;
    }
}
